JVM(Java virtual Maeaching) 자바 버츌얼 머신

Oracle 홈페이지 기준

Java는 다음과 같은 기능을 포함하는 객체 지향 프로그래밍 언어입니다.
* 플랫폼 독립성 - Java 애플리케이션은 클래스 파일에 저장되고 JVM에 로드되는 바이트코드 로 컴파일됩니다. 애플리케이션은 JVM에서 실행되기 때문에 다양한 운영 체제와 장치에서 실행할 수 있습니다.
* 객체 지향 - Java는 C 및 C++의 많은 기능을 취하고 이를 개선한 객체 지향 언어입니다.
* 자동 가비지 수집 - Java는 자동으로 메모리를 할당 및 할당 해제하여 프로그램이 해당 작업에 부담을 갖지 않도록 합니다.
* 풍부한 표준 라이브러리 - Java에는 입력/출력, 네트워킹 및 날짜 조작과 같은 작업을 수행하는 데 사용할 수 있는 수많은 미리 만들어진 개체가 포함되어 있습니다.

자바 개발 키트
JDK(Java Development Kit)는 Java 애플리케이션을 개발하기 위한 도구 모음입니다. JDK를 사용하면 Java 프로그래밍 언어로 작성된 프로그램을 컴파일하고 JVM에서 실행할 수 있습니다. 또한 JDK는 애플리케이션을 패키징하고 배포하기 위한 도구를 제공합니다.
JDK와 JRE는 Java API (Java Application Programming Interface )를 공유합니다. Java API는 개발자가 Java 응용 프로그램을 만드는 데 사용하는 사전 패키지 라이브러리 모음입니다. Java API는 문자열 조작, 날짜/시간 처리, 네트워킹 및 데이터 구조 구현(예: 목록, 맵, 스택 및 대기열)을 포함한 많은 일반적인 프로그래밍 작업을 완료하는 도구를 제공하여 개발을 더 쉽게 만듭니다.


자바 가상 머신
JVM(Java Virtual Machine)은 추상 컴퓨팅 머신입니다. JVM은 그 안에서 실행되도록 작성된 프로그램에 대해 기계처럼 보이는 프로그램입니다. 이러한 방식으로 Java 프로그램은 동일한 인터페이스 및 라이브러리 세트에 작성됩니다. 특정 운영 체제에 대한 각 JVM 구현은 Java 프로그래밍 명령을 로컬 운영 체제에서 실행되는 명령 및 명령으로 변환합니다. 이러한 방식으로 Java 프로그램은 플랫폼 독립성을 달성합니다.
Sun Microsystems, Inc.에서 수행한 Java 가상 머신의 첫 번째 프로토타입 구현은 현대의 PDA(Personal Digital Assistant)와 유사한 휴대용 장치에서 호스팅하는 소프트웨어의 Java 가상 머신 명령 세트를 에뮬레이트했습니다. Oracle의 현재 구현은 모바일, 데스크탑 및 서버 장치에서 Java 가상 머신을 에뮬레이트하지만 Java 가상 머신은 특정 구현 기술, 호스트 하드웨어 또는 호스트 운영 체제를 가정하지 않습니다. 본질적으로 해석되지는 않지만 명령 세트를 실리콘 CPU의 명령 세트로 컴파일하여 구현할 수 있습니다. 마이크로코드로 구현되거나 실리콘으로 직접 구현될 수도 있습니다.
Java 가상 머신은 Java 프로그래밍 언어에 대해 아무 것도 모르고 특정 바이너리 형식인 클래스 파일 형식만 알고 있습니다. 클래스 파일에는 Java 가상 머신 명령어(또는 바이트코드)와 기호 테이블, 기타 보조 정보가 포함되어 있습니다.
보안을 위해 Java 가상 머신은 클래스 파일의 코드에 강력한 구문 및 구조적 제약을 부과합니다. 그러나 유효한 클래스 파일로 표현할 수 있는 기능을 가진 모든 언어는 Java 가상 머신에서 호스팅할 수 있습니다. 일반적으로 사용 가능한 기계 독립적인 플랫폼에 매료되어 다른 언어의 구현자는 해당 언어의 전달 수단으로 Java 가상 기계를 사용할 수 있습니다. 


핫스팟 아키텍처
HotSpot JVM은 기능 및 기능의 강력한 기반을 지원하고 고성능 및 대규모 확장성을 실현할 수 있는 기능을 지원하는 아키텍처를 보유하고 있습니다. 예를 들어, HotSpot JVM JIT 컴파일러는 동적 최적화를 생성합니다. 즉, Java 애플리케이션이 실행되는 동안 최적화 결정을 내리고 기본 시스템 아키텍처를 대상으로 하는 고성능 기본 기계 명령을 생성합니다. 또한 런타임 환경 및 다중 스레드 가비지 수집기의 성숙한 진화와 지속적인 엔지니어링을 통해 HotSpot JVM은 사용 가능한 가장 큰 컴퓨터 시스템에서도 높은 확장성을 제공합니다.

￼


JVM의 주요 구성 요소에는 클래스 로더, 런타임 데이터 영역 및 실행 엔진이 포함됩니다.


주요 핫스팟 구성 요소
    성능과 관련된 JVM의 주요 구성 요소는 다음 이미지에 강조 표시되어 있습니다.
￼

성능을 조정할 때 중점을 두는 JVM의 세 가지 구성 요소가 있습니다. 힙 은 객체 데이터가 저장되는 곳입니다 . 
이 영역은 시작 시 선택한 가비지 수집기가 관리합니다. 대부분의 조정 옵션은 힙 크기 조정 및 상황에 가장 적합한 가비지 수집기 선택과 관련됩니다. 
JIT 컴파일러도 성능에 큰 영향을 미치지만 최신 버전의 JVM으로 조정할 필요가 거의 없습니다.

Java 애플리케이션을 조정할 때 초점은 응답성 또는 처리량


응답성 
응답성은 애플리케이션이나 시스템이 요청된 데이터 조각에 얼마나 빨리 응답하는지를 나타냅니다. 예는 다음과 같습니다.
* 데스크탑 UI가 이벤트에 응답하는 속도
* 웹사이트가 페이지를 반환하는 속도
* 데이터베이스 쿼리가 반환되는 속도
응답성에 중점을 둔 응용 프로그램의 경우 큰 일시 중지 시간은 허용되지 않습니다. 짧은 시간 안에 대응하는 데 중점을 둡니다.

처리량
처리량은 특정 기간 동안 애플리케이션의 작업량을 최대화하는 데 중점을 둡니다. 처리량을 측정하는 방법의 예는 다음과 같습니다.
* 주어진 시간에 완료된 트랜잭션 수입니다.
* 배치 프로그램이 한 시간에 완료할 수 있는 작업 수입니다.
* 한 시간에 완료할 수 있는 데이터베이스 쿼리 수입니다.
처리량에 중점을 둔 애플리케이션의 경우 높은 일시 중지 시간이 허용됩니다. 높은 처리량 애플리케이션은 더 오랜 기간 동안 벤치마크에 초점을 맞추기 때문에 빠른 응답 시간은 고려 사항이 아닙니다.


자동 가비지 수집은 힙 메모리를 살펴보고 사용 중인 개체와 사용하지 않는 개체를 식별하고 사용하지 않는 개체를 삭제하는 프로세스입니다. 
사용 중인 개체 또는 참조된 개체는 프로그램의 일부가 여전히 해당 개체에 대한 포인터를 유지하고 있음을 의미합니다. 
사용되지 않은 개체 또는 참조되지 않은 개체는 프로그램의 어떤 부분에서도 더 이상 참조되지 않습니다. 
따라서 참조되지 않은 개체가 사용하는 메모리를 회수할 수 있습니다.C와 같은 프로그래밍 언어에서 메모리 할당 및 할당 해제는 수동 프로세스입니다. 
Java에서 메모리 할당 해제 프로세스는 가비지 수집기에 의해 자동으로 처리됩니다. 기본 프로세스는 다음과 같이 설명할 수 있습니다.
￼

1. 2단계: 일반 삭제일반 삭제는 참조되지 않은 개체를 제거하여 참조된 개체와 포인터를 여유 공간으로 남깁니다.
￼
2. 메모리 할당자는 새 개체를 할당할 수 있는 여유 공간 블록에 대한 참조를 보유합니다.
3. 2a단계: 압축을 통한 삭제성능을 더욱 향상시키기 위해 참조되지 않은 개체를 삭제하는 것 외에도 참조된 나머지 개체를 압축할 수도 있습니다. 참조된 개체를 함께 이동하면 새 메모리 할당이 훨씬 쉽고 빨라집니다.
￼



1. 왜 세대별 쓰레기 수거인가?앞에서 언급했듯이 JVM의 모든 개체를 표시하고 압축해야 하는 것은 비효율적입니다. 더 많은 개체가 할당됨에 따라 개체 목록이 늘어나고 가비지 수집 시간이 점점 더 길어집니다. 그러나 응용 프로그램에 대한 경험적 분석에 따르면 대부분의 개체는 수명이 짧습니다.다음은 그러한 데이터의 예입니다. Y 축은 할당된 바이트 수를 표시하고 X 액세스는 시간에 따라 할당된 바이트 수를 표시합니다.
￼
보시다시피 시간이 지남에 따라 점점 더 적은 수의 개체가 할당됩니다. 
사실 대부분의 개체는 그래프 왼쪽에 더 높은 값으로 표시되는 것처럼 수명이 매우 짧습니다.

1. JVM 세대객체 할당 동작에서 학습한 정보는 JVM의 성능을 향상시키는 데 사용할 수 있습니다. 따라서 힙은 더 작은 부분 또는 세대로 나뉩니다. 힙 부분은 Young Generation, Old or Tenured Generation, Permanent Generation입니다.
￼
2. Young Generation 은 모든 새로운 객체가 할당되고 에이징되는 곳입니다 . 젊은 세대가 가득 차면 사소한 가비지 수집 이 발생합니다 . 개체 사망률이 높다고 가정하면 마이너 컬렉션을 최적화할 수 있습니다. 죽은 물건으로 가득 찬 젊은 세대는 매우 빠르게 수집됩니다. 살아남은 일부 개체는 노화되어 결국 구세대로 이동합니다.세계 이벤트 중지 - 모든 사소한 가비지 수집은 "세계 중지" 이벤트입니다. 이는 작업이 완료될 때까지 모든 애플리케이션 스레드가 중지됨을 의미합니다. 사소한 가비지 수집은 항상 Stop World 이벤트입니다.
3. Old Generation 은 오래 살아남은 개체를 저장하는 데 사용됩니다. 일반적으로 젊은 세대 개체에 대해 임계값이 설정되고 해당 연령이 충족되면 개체가 이전 세대로 이동합니다. 결국 구세대를 수집해야 합니다. 이 이벤트를 주요 가비지 수집 이라고 합니다 .주요 가비지 수집도 Stop World 이벤트입니다. 종종 주요 컬렉션은 모든 살아있는 개체를 포함하기 때문에 훨씬 느립니다. 따라서 반응형 애플리케이션의 경우 주요 가비지 수집을 최소화해야 합니다. 또한 주요 가비지 수집에 대한 Stop World 이벤트의 길이는 이전 세대 공간에 사용되는 가비지 수집기의 종류에 따라 영향을 받습니다.
4. 영구 생성 에는 응용 프로그램에서 사용되는 클래스 및 메서드를 설명하기 위해 JVM이 필요로 하는 메타데이터가 포함됩니다 . 영구 생성은 애플리케이션에서 사용 중인 클래스를 기반으로 런타임 시 JVM에 의해 채워집니다. 또한 Java SE 라이브러리 클래스 및 메서드를 여기에 저장할 수 있습니다. JVM이 클래스가 더 이상 필요하지 않고 다른 클래스를 위한 공간이 필요할 수 있음을 발견하면 클래스가 수집(언로드)될 수 있습니다. 영구 생성은 전체 가비지 수집에 포함됩니다.

1. 힙이 다른 세대로 분리된 이유를 이해했으므로 이제 이러한 공간이 정확히 어떻게 상호 작용하는지 살펴볼 차례입니다. 다음 그림은 JVM의 객체 할당 및 에이징 프로세스를 안내합니다.
2. 먼저 eden 공간에 새 객체가 할당됩니다. 두 생존자 공간은 모두 비어 있습니다.
￼
3. eden 공간이 가득 차면 사소한 가비지 수집이 트리거됩니다.
￼
4. 참조된 개체는 첫 번째 생존 공간으로 이동됩니다. 참조되지 않은 개체는 eden space가 지워지면 삭제됩니다.
￼
5. 다음 마이너 GC에서 동일한 일이 eden 공간에 대해 발생합니다. 참조되지 않은 개체는 삭제되고 참조된 개체는 생존 공간으로 이동됩니다. 다만, 이 경우 2차 생존공간(S1)으로 이동한다. 또한 첫 번째 생존 공간(S0)에 있는 마지막 마이너 GC의 개체는 나이가 증가하고 S1으로 이동됩니다. 살아남은 모든 객체가 S1으로 이동되면 S0과 eden이 모두 지워집니다. 이제 생존자 공간에 다르게 노화된 객체가 있음을 주목하십시오.
￼
6. 다음 마이너 GC에서 동일한 프로세스가 반복됩니다. 그러나 이번에는 생존자 공간이 바뀝니다. 참조된 개체는 S0으로 이동됩니다. 살아남은 물체는 노화됩니다. 에덴과 S1 클리어.
￼
7. 이 슬라이드는 프로모션을 보여줍니다. 마이너 GC 후 오래된 객체가 특정 연령 임계값(이 예에서는 8)에 도달하면 젊은 세대에서 이전 세대로 승격됩니다.
￼
8. 마이너 GC가 계속 발생함에 따라 개체는 계속해서 이전 세대 공간으로 승격됩니다.
￼
9. 그래서 그것은 젊은 세대와 함께 전체 과정을 거의 다룹니다. 결국 주요 GC는 해당 공간을 정리하고 압축하는 구세대에서 수행됩니다.
￼


